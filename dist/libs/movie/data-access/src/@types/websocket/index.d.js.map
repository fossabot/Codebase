{"version":3,"sources":["../../../../../../../libs/movie/data-access/node_modules/@types/websocket/index.d.ts"],"sourcesContent":["// Type definitions for websocket 1.0\n// Project: https://github.com/theturtle32/WebSocket-Node\n// Definitions by: Paul Loyd <https://github.com/loyd>,\n//                 Kay Schecker <https://github.com/flynetworks>,\n//                 Zhao Lei <https://github.com/zhaoleimxd>\n//                 Sheng Chen <https://github.com/jdneo>,\n//                 Matthew Peveler <https://github.com/MasterOdin>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.2\n\n/// <reference types=\"node\" />\n\nimport events = require('events');\nimport http = require('http');\nimport https = require('https');\nimport net = require('net');\nimport url = require('url');\n\nexport interface IStringified {\n    toString: (...args: any[]) => string;\n}\n\nexport interface IConfig {\n    /**\n     * The maximum allowed received frame size in bytes.\n     * Single frame messages will also be limited to this maximum.\n     * @default 1MiB\n     */\n    maxReceivedFrameSize?: number | undefined;\n\n    /**\n     * The maximum allowed aggregate message size (for fragmented messages) in bytes\n     * @default 8MiB\n     */\n    maxReceivedMessageSize?: number | undefined;\n\n    /**\n     * Whether or not to fragment outgoing messages. If true, messages will be\n     * automatically fragmented into chunks of up to `fragmentationThreshold` bytes.\n     * @default true\n     */\n    fragmentOutgoingMessages?: boolean | undefined;\n\n    /**\n     * The maximum size of a frame in bytes before it is automatically fragmented.\n     * @default 16KiB\n     */\n    fragmentationThreshold?: number | undefined;\n\n    /**\n     * If true, fragmented messages will be automatically assembled and the full\n     * message will be emitted via a `message` event. If false, each frame will be\n     * emitted on the `connection` object via a `frame` event and the application\n     * will be responsible for aggregating multiple fragmented frames. Single-frame\n     * messages will emit a `message` event in addition to the `frame` event.\n     * @default true\n     */\n    assembleFragments?: boolean | undefined;\n\n    /**\n     * The number of milliseconds to wait after sending a close frame for an\n     * `acknowledgement` to come back before giving up and just closing the socket.\n     * @default 5000\n     */\n    closeTimeout?: number | undefined;\n\n    /**\n     * The Nagle Algorithm makes more efficient use of network resources by introducing a\n     * small delay before sending small packets so that multiple messages can be batched\n     * together before going onto the wire. This however comes at the cost of latency.\n     * @default true\n     */\n    disableNagleAlgorithm?: boolean | undefined;\n}\n\nexport interface IServerConfig extends IConfig {\n    /** The http or https server instance(s) to attach to */\n    httpServer: http.Server | https.Server | Array<http.Server | https.Server>;\n\n    /**\n     * The maximum allowed received frame size in bytes.\n     * Single frame messages will also be limited to this maximum.\n     * @default 64KiB\n     */\n    maxReceivedFrameSize?: number | undefined;\n\n    /**\n     * The maximum allowed aggregate message size (for fragmented messages) in bytes.\n     * @default 1MiB\n     */\n    maxReceivedMessageSize?: number | undefined;\n\n    /**\n     * If true, the server will automatically send a ping to all clients every\n     * `keepaliveInterval` milliseconds. Each client has an independent `keepalive`\n     * timer, which is reset when any data is received from that client.\n     * @default true\n     */\n    keepalive?: boolean | undefined;\n\n    /**\n     * The interval in milliseconds to send `keepalive` pings to connected clients.\n     * @default 20000\n     */\n    keepaliveInterval?: number | undefined;\n\n    /**\n     * If true, the server will consider any connection that has not received any\n     * data within the amount of time specified by `keepaliveGracePeriod` after a\n     * `keepalive` ping has been sent. Ignored if `keepalive` is false.\n     * @default true\n     */\n    dropConnectionOnKeepaliveTimeout?: boolean | undefined;\n\n    /**\n     * The amount of time to wait after sending a `keepalive` ping before closing\n     * the connection if the connected peer does not respond. Ignored if `keepalive`\n     * or `dropConnectionOnKeepaliveTimeout` are false. The grace period timer is\n     * reset when any data is received from the client.\n     * @default 10000\n     */\n    keepaliveGracePeriod?: number | undefined;\n\n    /**\n     * Whether to use native TCP keep-alive instead of WebSockets ping\n     * and pong packets.  Native TCP keep-alive sends smaller packets\n     * on the wire and so uses bandwidth more efficiently.  This may\n     * be more important when talking to mobile devices.\n     * If this value is set to true, then these values will be ignored:\n     *   keepaliveGracePeriod\n     *   dropConnectionOnKeepaliveTimeout\n     * @default false\n     */\n    useNativeKeepalive?: boolean | undefined;\n\n    /**\n     * If this is true, websocket connections will be accepted regardless of the path\n     * and protocol specified by the client. The protocol accepted will be the first\n     * that was requested by the client.\n     * @default false\n     */\n    autoAcceptConnections?: boolean | undefined;\n\n    /**\n     * Whether or not the X-Forwarded-For header should be respected.\n     * It's important to set this to 'true' when accepting connections\n     * from untrusted clients, as a malicious client could spoof its\n     * IP address by simply setting this header.  It's meant to be added\n     * by a trusted proxy or other intermediary within your own\n     * infrastructure.\n     * See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n     * @default false\n     */\n    ignoreXForwardedFor?: boolean | undefined;\n}\n\nexport class server extends events.EventEmitter {\n    config?: IServerConfig | undefined;\n    connections: connection[];\n    pendingRequests: request[];\n\n    constructor(serverConfig?: IServerConfig);\n\n    /** Send binary or UTF-8 message for each connection */\n    broadcast(data: Buffer | IStringified): void;\n    /** Send binary message for each connection */\n    broadcastBytes(data: Buffer): void;\n    /** Send UTF-8 message for each connection */\n    broadcastUTF(data: IStringified): void;\n    /** Attach the `server` instance to a Node http.Server instance */\n    mount(serverConfig: IServerConfig): void;\n\n    /**\n     * Detach the `server` instance from the Node http.Server instance.\n     * All existing connections are left alone and will not be affected,\n     * but no new WebSocket connections will be accepted.\n     */\n    unmount(): void;\n\n    /** Close all open WebSocket connections */\n    closeAllConnections(): void;\n    /** Close all open WebSocket connections and unmount the server */\n    shutDown(): void;\n\n    handleUpgrade(request: http.IncomingMessage, socket: net.Socket): void;\n    handleRequestAccepted(connection: connection): void;\n    handleConnectionClose(connection: connection, closeReason: number, description: string): void;\n    handleRequestResolved(request: request): void;\n\n    // Events\n    on(event: 'request', cb: (request: request) => void): this;\n    on(event: 'connect', cb: (connection: connection) => void): this;\n    on(event: 'close', cb: (connection: connection, reason: number, desc: string) => void): this;\n    addListener(event: 'request', cb: (request: request) => void): this;\n    addListener(event: 'connect', cb: (connection: connection) => void): this;\n    addListener(event: 'close', cb: (connection: connection, reason: number, desc: string) => void): this;\n}\n\nexport interface ICookie {\n    name: string;\n    value: string;\n    path?: string | undefined;\n    domain?: string | undefined;\n    expires?: Date | undefined;\n    maxage?: number | undefined;\n    secure?: boolean | undefined;\n    httponly?: boolean | undefined;\n}\n\nexport interface IExtension {\n    name: string;\n    value: string;\n}\n\nexport class request extends events.EventEmitter {\n    /** A reference to the original Node HTTP request object */\n    httpRequest: http.IncomingMessage;\n    /** This will include the port number if a non-standard port is used */\n    host: string;\n    /** A string containing the path that was requested by the client */\n    resource: string;\n    /** `Sec-WebSocket-Key` */\n    key: string;\n    /** Parsed resource, including the query string parameters */\n    resourceURL: url.Url;\n\n    /**\n     * Client's IP. If an `X-Forwarded-For` header is present, the value will be taken\n     * from that header to facilitate WebSocket servers that live behind a reverse-proxy\n     */\n    remoteAddress: string;\n    remoteAddresses: string[];\n\n    /**\n     * If the client is a web browser, origin will be a string containing the URL\n     * of the page containing the script that opened the connection.\n     * If the client is not a web browser, origin may be `null` or \"*\".\n     */\n    origin: string;\n\n    /** The version of the WebSocket protocol requested by the client */\n    webSocketVersion: number;\n    /** An array containing a list of extensions requested by the client */\n    requestedExtensions: any[];\n\n    cookies: ICookie[];\n    socket: net.Socket;\n\n    /**\n     * List of strings that indicate the subprotocols the client would like to speak.\n     * The server should select the best one that it can support from the list and\n     * pass it to the `accept` function when accepting the connection.\n     * Note that all the strings in the `requestedProtocols` array will have been\n     * converted to lower case.\n     */\n    requestedProtocols: string[];\n    protocolFullCaseMap: { [key: string]: string };\n\n    serverConfig: IServerConfig;\n\n    _resolved: boolean;\n    _socketIsClosing: boolean;\n\n    constructor(socket: net.Socket, httpRequest: http.IncomingMessage, config: IServerConfig);\n\n    /**\n     * After inspecting the `request` properties, call this function on the\n     * request object to accept the connection. If you don't have a particular subprotocol\n     * you wish to speak, you may pass `null` for the `acceptedProtocol` parameter.\n     *\n     * @param [acceptedProtocol] case-insensitive value that was requested by the client\n     */\n    accept(acceptedProtocol?: string | null, allowedOrigin?: string, cookies?: ICookie[]): connection;\n\n    /**\n     * Reject connection.\n     * You may optionally pass in an HTTP Status code (such as 404) and a textual\n     * description that will be sent to the client in the form of an\n     * `X-WebSocket-Reject-Reason` header.\n     * Optional extra http headers can be added via Object key/values on extraHeaders.\n     */\n    reject(httpStatus?: number, reason?: string, extraHeaders?: object): void;\n\n    // Events\n    on(event: 'requestResolved' | 'requestRejected', cb: (request: this) => void): this;\n    on(event: 'requestAccepted', cb: (connection: connection) => void): this;\n    addListener(event: 'requestResolved' | 'requestRejected', cb: (request: this) => void): this;\n    addListener(event: 'requestAccepted', cb: (connection: connection) => void): this;\n\n    readHandshake(): void;\n\n    parseExtensions(extensionString: string): string[];\n\n    parseCookies(str: string): ICookie[] | void;\n\n    _handleSocketCloseBeforeAccept(): void;\n    _removeSocketCloseListeners(): void;\n    _verifyResolution(): void;\n}\n\nexport interface IUtf8Message {\n    type: 'utf8';\n    utf8Data: string;\n}\n\nexport interface IBinaryMessage {\n    type: 'binary';\n    binaryData: Buffer;\n}\n\nexport type Message = IUtf8Message | IBinaryMessage;\n\nexport interface IBufferList extends events.EventEmitter {\n    encoding: string;\n    length: number;\n    write(buf: Buffer): boolean;\n    end(buf: Buffer): void;\n    push(): void;\n\n    /**\n     * For each buffer, perform some action.\n     * If fn's result is a true value, cut out early.\n     */\n    forEach(fn: (buf: Buffer) => boolean): void;\n\n    /** Create a single buffer out of all the chunks */\n    join(start: number, end: number): Buffer;\n\n    /** Join all the chunks to existing buffer */\n    joinInto(buf: Buffer, offset: number, start: number, end: number): Buffer;\n\n    /**\n     * Advance the buffer stream by `n` bytes.\n     * If `n` the aggregate advance offset passes the end of the buffer list,\n     * operations such as `take` will return empty strings until enough data is pushed.\n     */\n    advance(n: number): IBufferList;\n\n    /**\n     * Take `n` bytes from the start of the buffers.\n     * If there are less than `n` bytes in all the buffers or `n` is undefined,\n     * returns the entire concatenated buffer string.\n     */\n    take(n: number, encoding?: string): any;\n    take(encoding?: string): any;\n\n    toString(): string;\n\n    // Events\n    on(event: 'advance', cb: (n: number) => void): this;\n    on(event: 'write', cb: (buf: Buffer) => void): this;\n    addListener(event: 'advance', cb: (n: number) => void): this;\n    addListener(event: 'write', cb: (buf: Buffer) => void): this;\n}\n\nexport class connection extends events.EventEmitter {\n    static CLOSE_REASON_NORMAL: number;\n    static CLOSE_REASON_GOING_AWAY: number;\n    static CLOSE_REASON_PROTOCOL_ERROR: number;\n    static CLOSE_REASON_UNPROCESSABLE_INPUT: number;\n    static CLOSE_REASON_RESERVED: number;\n    static CLOSE_REASON_NOT_PROVIDED: number;\n    static CLOSE_REASON_ABNORMAL: number;\n    static CLOSE_REASON_INVALID_DATA: number;\n    static CLOSE_REASON_POLICY_VIOLATION: number;\n    static CLOSE_REASON_MESSAGE_TOO_BIG: number;\n    static CLOSE_REASON_EXTENSION_REQUIRED: number;\n\n    static CLOSE_DESCRIPTIONS: {[code: number]: string};\n\n    /**\n     * After the connection is closed, contains a textual description of the reason for\n     * the connection closure, or `null` if the connection is still open.\n     */\n    closeDescription: string;\n\n    /**\n     * After the connection is closed, contains the numeric close reason status code,\n     * or `-1` if the connection is still open.\n     */\n    closeReasonCode: number;\n\n    /**\n     * The subprotocol that was chosen to be spoken on this connection. This field\n     * will have been converted to lower case.\n     */\n    protocol: string;\n\n    config: IConfig;\n    socket: net.Socket;\n    maskOutgoingPackets: boolean;\n    maskBytes: Buffer;\n    frameHeader: Buffer;\n    bufferList: IBufferList;\n    currentFrame: frame;\n    fragmentationSize: number;\n    frameQueue: frame[];\n    state: string;\n    waitingForCloseResponse: boolean;\n    receivedEnd: boolean;\n    closeTimeout: number;\n    assembleFragments: number;\n    maxReceivedMessageSize: number;\n    outputBufferFull: boolean;\n    inputPaused: boolean;\n    bytesWaitingToFlush: number;\n    socketHadError: boolean;\n\n    /** An array of extensions that were negotiated for this connection */\n    extensions: IExtension[];\n\n    /**\n     * The IP address of the remote peer as a string. In the case of a server,\n     * the `X-Forwarded-For` header will be respected and preferred for the purposes\n     * of populating this field. If you need to get to the actual remote IP address,\n     * `socket.remoteAddress` will provide it.\n     */\n    remoteAddress: string;\n\n    /** The version of the WebSocket protocol requested by the client */\n    webSocketVersion: number;\n    /** Whether or not the connection is still connected. Read-only */\n    connected: boolean;\n\n    _pingListenerCount: number;\n\n    constructor(socket: net.Socket, extensions: IExtension[], protocol: string,\n        maskOutgoingPackets: boolean, config: IConfig);\n\n    /**\n     * Close the connection. A close frame will be sent to the remote peer indicating\n     * that we wish to close the connection, and we will then wait for up to\n     * `config.closeTimeout` milliseconds for an acknowledgment from the remote peer\n     * before terminating the underlying socket connection.\n     */\n    close(reasonCode?: number, description?: string): void;\n\n    /**\n     * Send a close frame to the remote peer and immediately close the socket without\n     * waiting for a response. This should generally be used only in error conditions.\n     */\n    drop(reasonCode?: number, description?: string, skipCloseFrame?: boolean): void;\n\n    /**\n     * Immediately sends the specified string as a UTF-8 WebSocket message to the remote\n     * peer. If `config.fragmentOutgoingMessages` is true the message may be sent as\n     * multiple fragments if it exceeds `config.fragmentationThreshold` bytes.\n     */\n    sendUTF(data: IStringified, cb?: (err?: Error) => void): void;\n\n    /**\n     * Immediately sends the specified Node Buffer object as a Binary WebSocket message\n     * to the remote peer. If config.fragmentOutgoingMessages is true the message may be\n     * sent as multiple fragments if it exceeds config.fragmentationThreshold bytes.\n     */\n    sendBytes(buffer: Buffer, cb?: (err?: Error) => void): void;\n\n    /** Auto-detect the data type and send UTF-8 or Binary message */\n    send(data: Buffer | IStringified, cb?: (err?: Error) => void): void;\n\n    /** Sends a ping frame. Ping frames must not exceed 125 bytes in length. */\n    ping(data: Buffer | IStringified): void;\n\n    /**\n     * Sends a pong frame. Pong frames may be sent unsolicited and such pong frames will\n     * trigger no action on the receiving peer. Pong frames sent in response to a ping\n     * frame must mirror the payload data of the ping frame exactly.\n     * The `connection` object handles this internally for you, so there should\n     * be no need to use this method to respond to pings.\n     * Pong frames must not exceed 125 bytes in length.\n     */\n    pong(buffer: Buffer): void;\n\n    /**\n     * Serializes a `frame` object into binary data and immediately sends it to\n     * the remote peer. This is an advanced function, requiring you to manually compose\n     * your own `frame`. You should probably use sendUTF or sendBytes instead.\n     */\n    sendFrame(frame: frame, cb?: (err?: Error) => void): void;\n\n    /** Set or reset the `keepalive` timer when data is received */\n    setKeepaliveTimer(): void;\n    clearKeepaliveTimer(): void;\n    handleKeepaliveTimer(): void;\n    setGracePeriodTimer(): void;\n    clearGracePeriodTimer(): void;\n    handleGracePeriodTimer(): void;\n    handleSocketData(data: Buffer): void;\n    processReceivedData(): void;\n    handleSocketError(error: Error): void;\n    handleSocketEnd(): void;\n    handleSocketClose(hadError: boolean): void;\n    handleSocketDrain(): void;\n    handleSocketPause(): void;\n    handleSocketResume(): void;\n    pause(): void;\n    resume(): void;\n\n    setCloseTimer(): void;\n    clearCloseTimer(): void;\n    handleCloseTimer(): void;\n    processFrame(frame: frame): void;\n    fragmentAndSend(frame: frame, cb?: (err: Error) => void): void;\n    sendCloseFrame(reasonCode?: number, reasonText?: string, cb?: (err?: Error) => void): void;\n\n    _addSocketEventListeners(): void;\n\n    // Events\n    on(event: 'message', cb: (data: Message) => void): this;\n    on(event: 'frame', cb: (frame: frame) => void): this;\n    on(event: 'close', cb: (code: number, desc: string) => void): this;\n    on(event: 'error', cb: (err: Error) => void): this;\n    on(event: 'drain' | 'pause' | 'resume', cb: () => void): this;\n    on(event: 'ping', cb: (cancel: () => void, binaryPayload: Buffer) => void): this;\n    on(event: 'pong', cb: (binaryPayload: Buffer) => void): this;\n    addListener(event: 'message', cb: (data: Message) => void): this;\n    addListener(event: 'frame', cb: (frame: frame) => void): this;\n    addListener(event: 'close', cb: (code: number, desc: string) => void): this;\n    addListener(event: 'error', cb: (err: Error) => void): this;\n    addListener(event: 'drain' | 'pause' | 'resume', cb: () => void): this;\n    addListener(event: 'ping', cb: (cancel: () => void, binaryPayload: Buffer) => void): this;\n    addListener(event: 'pong', cb: (binaryPayload: Buffer) => void): this;\n}\n\nexport class frame {\n    /** Whether or not this is last frame in a fragmentation sequence */\n    fin: boolean;\n\n    /**\n     * Represents the RSV1 field in the framing. Setting this to true will result in\n     * a Protocol Error on the receiving peer.\n     */\n    rsv1: boolean;\n\n    /**\n     * Represents the RSV1 field in the framing. Setting this to true will result in\n     * a Protocol Error on the receiving peer.\n     */\n    rsv2: boolean;\n\n    /**\n     * Represents the RSV1 field in the framing. Setting this to true will result in\n     * a Protocol Error on the receiving peer.\n     */\n    rsv3: boolean;\n\n    /**\n     * Whether or not this frame is (or should be) masked. For outgoing frames, when\n     * connected as a client, this flag is automatically forced to true by `connection`.\n     * Outgoing frames sent from the server-side of a connection are not masked.\n     */\n    mask: number;\n\n    /**\n     * Identifies which kind of frame this is.\n     *\n     * Hex  - Dec - Description\n     * 0x00 -   0 - Continuation\n     * 0x01 -   1 - Text Frame\n     * 0x02 -   2 - Binary Frame\n     * 0x08 -   8 - Close Frame\n     * 0x09 -   9 - Ping Frame\n     * 0x0A -  10 - Pong Frame\n     */\n    opcode: number;\n\n    /**\n     * Identifies the length of the payload data on a received frame.\n     * When sending a frame, will be automatically calculated from `binaryPayload` object.\n     */\n    length: number;\n\n    /**\n     * The binary payload data.\n     * Even text frames are sent with a Buffer providing the binary payload data.\n     */\n    binaryPayload: Buffer;\n\n    maskBytes: Buffer;\n    frameHeader: Buffer;\n    config: IConfig;\n    maxReceivedFrameSize: number;\n    protocolError: boolean;\n    dropReason: string;\n    frameTooLarge: boolean;\n    invalidCloseFrameLength: boolean;\n    parseState: number;\n    closeStatus: number;\n\n    addData(bufferList: IBufferList): boolean;\n    throwAwayPayload(bufferList: IBufferList): boolean;\n    toBuffer(nullMask: boolean): Buffer;\n    toString(): string;\n}\n\nexport interface IClientConfig extends IConfig {\n    /**\n     * Which version of the WebSocket protocol to use when making the connection.\n     * Currently supported values are 8 and 13. This option will be removed once the\n     * protocol is finalized by the IETF It is only available to ease the transition\n     * through the intermediate draft protocol versions. The only thing this affects\n     * the name of the Origin header.\n     * @default 13\n     */\n    webSocketVersion?: number | undefined;\n\n    /**\n     * Options to pass to `https.request` if connecting via TLS.\n     * @see https://nodejs.org/api/https.html#https_https_request_options_callback\n     */\n    tlsOptions?: https.RequestOptions | undefined;\n}\n\nexport class client extends events.EventEmitter {\n    constructor(ClientConfig?: IClientConfig);\n\n    /**\n     * Establish a connection. The remote server will select the best subprotocol that\n     * it supports and send that back when establishing the connection.\n     *\n     * @param requestUrl should be a standard websocket url\n     * @param [requestedProtocols] list of subprotocols supported by the client.\n     *     The remote server will select the best subprotocol that it supports and send that back when establishing the connection.\n     * @param [origin] Used in user-agent scenarios to identify the page containing\n     *     any scripting content that caused the connection to be requested.\n     * @param [headers] additional arbitrary HTTP request headers to send along with the request.\n     *     This may be used to pass things like access tokens, etc. so that the server can verify authentication/authorization\n     *     before deciding to accept and open the full WebSocket connection.\n     * @param [extraRequestOptions] additional configuration options to be passed to `http.request` or `https.request`.\n     *     This can be used to pass a custom `agent` to enable `client` usage from behind an HTTP or HTTPS proxy server\n     *     using {@link https://github.com/koichik/node-tunnel|koichik/node-tunnel} or similar.\n     * @example client.connect('ws://www.mygreatapp.com:1234/websocketapp/')\n     */\n    connect(requestUrl: url.Url | string, requestedProtocols?: string | string[], origin?: string, headers?: http.OutgoingHttpHeaders, extraRequestOptions?: http.RequestOptions): void;\n\n    /**\n     * Will cancel an in-progress connection request before either the `connect` event or the `connectFailed` event has been emitted.\n     * If the `connect` or `connectFailed` event has already been emitted, calling `abort()` will do nothing.\n     */\n    abort(): void;\n\n    // Events\n    on(event: 'connect', cb: (connection: connection) => void): this;\n    on(event: 'connectFailed', cb: (err: Error) => void): this;\n    on(event: 'httpResponse', cb: (response: http.IncomingMessage, client: client) => void): this;\n    addListener(event: 'connect', cb: (connection: connection) => void): this;\n    addListener(event: 'connectFailed', cb: (err: Error) => void): this;\n    addListener(event: 'httpResponse', cb: (response: http.IncomingMessage, client: client) => void): this;\n}\n\nexport interface IRouterRequest extends events.EventEmitter {\n    webSocketRequest: request;\n    protocol: string | null;\n\n    /**\n     * If the client is a web browser, origin will be a string containing the URL\n     * of the page containing the script that opened the connection.\n     * If the client is not a web browser, origin may be `null` or \"*\".\n     */\n    origin: string;\n\n    /** A string containing the path that was requested by the client */\n    resource: string;\n    /** Parsed resource, including the query string parameters */\n    resourceURL: url.Url;\n\n    /** A reference to the original Node HTTP request object */\n    httpRequest: http.IncomingMessage;\n\n    /**\n     * Client's IP. If an `X-Forwarded-For` header is present, the value will be taken\n     * from that header to facilitate WebSocket servers that live behind a reverse-proxy\n     */\n    remoteAddress: string;\n\n    /** The version of the WebSocket protocol requested by the client */\n    webSocketVersion: number;\n    /** An array containing a list of extensions requested by the client */\n    requestedExtensions: any[];\n\n    cookies: ICookie[];\n\n    /**\n     * After inspecting the `request` properties, call this function on the\n     * request object to accept the connection. If you don't have a particular subprotocol\n     * you wish to speak, you may pass `null` for the `acceptedProtocol` parameter.\n     *\n     * @param [acceptedProtocol] case-insensitive value that was requested by the client\n     */\n    accept(acceptedProtocol?: string, allowedOrigin?: string, cookies?: ICookie[]): connection;\n\n    /**\n     * Reject connection.\n     * You may optionally pass in an HTTP Status code (such as 404) and a textual\n     * description that will be sent to the client in the form of an\n     * `X-WebSocket-Reject-Reason` header.\n     */\n    reject(httpStatus?: number, reason?: string): void;\n\n    // Events\n    on(event: 'requestAccepted', cb: (connection: connection) => void): this;\n    on(event: 'requestRejected', cb: (request: this) => void): this;\n    addListener(event: 'requestAccepted', cb: (connection: connection) => void): this;\n    addListener(event: 'requestRejected', cb: (request: this) => void): this;\n}\n\nexport interface IRouterConfig {\n    /*\n     * The WebSocketServer instance to attach to.\n     */\n    server: server;\n}\n\nexport interface IRouterHandler {\n    path: string;\n    pathString: string;\n    protocol: string;\n    callback: (request: IRouterRequest) => void;\n}\n\nexport class router extends events.EventEmitter {\n    handlers: IRouterHandler[];\n\n    constructor(config?: IRouterConfig);\n\n    /** Attach to WebSocket server */\n    attachServer(server: server): void;\n\n    /** Detach from WebSocket server */\n    detachServer(): void;\n\n    mount(path: string | RegExp, protocol: string | null, callback: (request: IRouterRequest) => void): void;\n\n    unmount(path: string | RegExp, protocol?: string): void;\n\n    findHandlerIndex(pathString: string, protocol: string): number;\n\n    pathToRegExp(path: string): RegExp;\n    pathToRegEx(path: RegExp): RegExp;\n\n    handleRequest(request: request): void;\n}\n\nexport interface ICloseEvent {\n    code: number;\n    reason: string;\n    wasClean: boolean;\n}\n\nexport interface IMessageEvent {\n    data: string | Buffer | ArrayBuffer;\n}\n\nexport class w3cwebsocket {\n    static CONNECTING: number;\n    static OPEN: number;\n    static CLOSING: number;\n    static CLOSED: number;\n\n    _url: string;\n    _readyState: number;\n    _protocol?: string | undefined;\n    _extensions: IExtension[];\n    _bufferedAmount: number;\n    _binaryType: 'arraybuffer';\n    _connection?: connection | undefined;\n    _client: client;\n\n    url: string;\n    readyState: number;\n    protocol?: string | undefined;\n    extensions: IExtension[];\n    bufferedAmount: number;\n\n    binaryType: 'arraybuffer';\n\n    CONNECTING: number;\n    OPEN: number;\n    CLOSING: number;\n    CLOSED: number;\n\n    onopen: () => void;\n    onerror: (error: Error) => void;\n    onclose: (event: ICloseEvent) => void;\n    onmessage: (message: IMessageEvent) => void;\n\n    constructor(\n        url: string,\n        protocols?: string | string[],\n        origin?: string,\n        headers?: http.OutgoingHttpHeaders,\n        requestOptions?: object,\n        IClientConfig?: IClientConfig,\n    );\n\n    send(data: ArrayBufferView | ArrayBuffer | Buffer | IStringified): void;\n    close(code?: number, reason?: string): void;\n}\n\nexport const deprecation: {\n    disableWarnings: boolean;\n    deprecationWarningMap: {[name: string]: string};\n    warn(deprecationName: string): void;\n};\n\nexport const version: string;\n"],"names":["events","http","https","net","url","server","EventEmitter","request","connection","frame","client","router","w3cwebsocket","deprecation","version"],"mappings":";;AAAA,EAAqC,AAArC,mCAAqC;AACrC,EAAyD,AAAzD,uDAAyD;AACzD,EAAuD,AAAvD,qDAAuD;AACvD,EAAiE,AAAjE,+DAAiE;AACjE,EAA2D,AAA3D,yDAA2D;AAC3D,EAAyD,AAAzD,uDAAyD;AACzD,EAAkE,AAAlE,gEAAkE;AAClE,EAAkE,AAAlE,gEAAkE;AAClE,EAA0B,AAA1B,wBAA0B;AAE1B,EAA8B,AAA9B,4BAA8B;AAE9B,KAAM,CAACA,MAAM,WAAW,CAAQ;AAChC,KAAM,CAACC,IAAI,WAAW,CAAM;AAC5B,KAAM,CAACC,KAAK,WAAW,CAAO;AAC9B,KAAM,CAACC,GAAG,WAAW,CAAK;AAC1B,KAAM,CAACC,GAAG,WAAW,CAAK;AA4InB,GAAK,CAACC,MAAM,SAANA,MAAM,SAASL,MAAM,CAACM,YAAY;;QAAlCD,MAAM,GAANA,MAAM;AA0DZ,GAAK,CAACE,OAAO,SAAPA,OAAO,SAASP,MAAM,CAACM,YAAY;;QAAnCC,OAAO,GAAPA,OAAO;AA6Ib,GAAK,CAACC,UAAU,SAAVA,UAAU,SAASR,MAAM,CAACM,YAAY;;QAAtCE,UAAU,GAAVA,UAAU;AAyKhB,GAAK,CAACC,KAAK,SAALA,KAAK;;QAALA,KAAK,GAALA,KAAK;AAyFX,GAAK,CAACC,MAAM,SAANA,MAAM,SAASV,MAAM,CAACM,YAAY;;QAAlCI,MAAM,GAANA,MAAM;AA2GZ,GAAK,CAACC,MAAM,SAANA,MAAM,SAASX,MAAM,CAACM,YAAY;;QAAlCK,MAAM,GAANA,MAAM;AAiCZ,GAAK,CAACC,YAAY,SAAZA,YAAY;;QAAZA,YAAY,GAAZA,YAAY;AA8ClB,KAAK,CAACC,WAAW;QAAXA,WAAW,GAAXA,WAAW;AAMjB,KAAK,CAACC,OAAO;QAAPA,OAAO,GAAPA,OAAO"}