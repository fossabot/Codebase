{"version":3,"sources":["../../../../../../../libs/movie/data-access/node_modules/type/promise/is.js"],"sourcesContent":["\"use strict\";\n\nvar isPrototype = require(\"../prototype/is\");\n\n// In theory we could rely on Symbol.toStringTag directly,\n// still early native implementation (e.g. in FF) predated symbols\nvar objectToString = Object.prototype.toString\n  , objectTaggedString = objectToString.call(Promise.resolve());\n\nmodule.exports = function (value) {\n\tif (!value) return false;\n\n\t// Sanity check (reject objects which do not expose common Promise interface)\n\ttry {\n\t\tif (typeof value.then !== \"function\") return false;\n\t\tif (typeof value[\"catch\"] !== \"function\") return false;\n\t} catch (error) {\n\t\treturn false;\n\t}\n\n\t// Ensure its native Promise object (has [[PromiseState]] slot)\n\t// Note: it's not 100% precise as string tag may be overriden\n\t// and other objects could be hacked to expose it\n\tif (objectToString.call(value) !== objectTaggedString) return false;\n\n\treturn !isPrototype(value);\n};\n"],"names":["isPrototype","require","objectToString","Object","prototype","toString","objectTaggedString","call","Promise","resolve","module","exports","value","then","error"],"mappings":"AAAA,CAAY;AAEZ,GAAG,CAACA,WAAW,GAAGC,OAAO,CAAC,CAAiB;AAE3C,EAA0D,AAA1D,wDAA0D;AAC1D,EAAkE,AAAlE,gEAAkE;AAClE,GAAG,CAACC,cAAc,GAAGC,MAAM,CAACC,SAAS,CAACC,QAAQ,EAC1CC,kBAAkB,GAAGJ,cAAc,CAACK,IAAI,CAACC,OAAO,CAACC,OAAO;AAE5DC,MAAM,CAACC,OAAO,GAAG,QAAQ,CAAEC,KAAK,EAAE,CAAC;IAClC,EAAE,GAAGA,KAAK,EAAE,MAAM,CAAC,KAAK;IAExB,EAA6E,AAA7E,2EAA6E;IAC7E,GAAG,CAAC,CAAC;QACJ,EAAE,EAAE,MAAM,CAACA,KAAK,CAACC,IAAI,KAAK,CAAU,WAAE,MAAM,CAAC,KAAK;QAClD,EAAE,EAAE,MAAM,CAACD,KAAK,CAAC,CAAO,YAAM,CAAU,WAAE,MAAM,CAAC,KAAK;IACvD,CAAC,CAAC,KAAK,EAAEE,KAAK,EAAE,CAAC;QAChB,MAAM,CAAC,KAAK;IACb,CAAC;IAED,EAA+D,AAA/D,6DAA+D;IAC/D,EAA6D,AAA7D,2DAA6D;IAC7D,EAAiD,AAAjD,+CAAiD;IACjD,EAAE,EAAEZ,cAAc,CAACK,IAAI,CAACK,KAAK,MAAMN,kBAAkB,EAAE,MAAM,CAAC,KAAK;IAEnE,MAAM,EAAEN,WAAW,CAACY,KAAK;AAC1B,CAAC"}