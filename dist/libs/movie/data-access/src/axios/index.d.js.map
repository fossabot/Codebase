{"version":3,"sources":["../../../../../../libs/movie/data-access/node_modules/axios/index.d.ts"],"sourcesContent":["// TypeScript Version: 3.0\n\nexport type AxiosRequestHeaders = Record<string, string | number | boolean>;\n\nexport type AxiosResponseHeaders = Record<string, string> & {\n  \"set-cookie\"?: string[]\n};\n\nexport interface AxiosRequestTransformer {\n  (data: any, headers?: AxiosRequestHeaders): any;\n}\n\nexport interface AxiosResponseTransformer {\n  (data: any, headers?: AxiosResponseHeaders): any;\n}\n\nexport interface AxiosAdapter {\n  (config: AxiosRequestConfig): AxiosPromise;\n}\n\nexport interface AxiosBasicCredentials {\n  username: string;\n  password: string;\n}\n\nexport interface AxiosProxyConfig {\n  host: string;\n  port: number;\n  auth?: {\n    username: string;\n    password: string;\n  };\n  protocol?: string;\n}\n\nexport type Method =\n  | 'get' | 'GET'\n  | 'delete' | 'DELETE'\n  | 'head' | 'HEAD'\n  | 'options' | 'OPTIONS'\n  | 'post' | 'POST'\n  | 'put' | 'PUT'\n  | 'patch' | 'PATCH'\n  | 'purge' | 'PURGE'\n  | 'link' | 'LINK'\n  | 'unlink' | 'UNLINK';\n\nexport type ResponseType =\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'text'\n  | 'stream';\n\n  export type responseEncoding =\n  | 'ascii' | 'ASCII'\n  | 'ansi' | 'ANSI'\n  | 'binary' | 'BINARY'\n  | 'base64' | 'BASE64'\n  | 'base64url' | 'BASE64URL'\n  | 'hex' | 'HEX'\n  | 'latin1' | 'LATIN1'\n  | 'ucs-2' | 'UCS-2'\n  | 'ucs2' | 'UCS2'\n  | 'utf-8' | 'UTF-8'\n  | 'utf8' | 'UTF8'\n  | 'utf16le' | 'UTF16LE';\n\nexport interface TransitionalOptions {\n  silentJSONParsing?: boolean;\n  forcedJSONParsing?: boolean;\n  clarifyTimeoutError?: boolean;\n}\n\nexport interface AxiosRequestConfig<D = any> {\n  url?: string;\n  method?: Method;\n  baseURL?: string;\n  transformRequest?: AxiosRequestTransformer | AxiosRequestTransformer[];\n  transformResponse?: AxiosResponseTransformer | AxiosResponseTransformer[];\n  headers?: AxiosRequestHeaders;\n  params?: any;\n  paramsSerializer?: (params: any) => string;\n  data?: D;\n  timeout?: number;\n  timeoutErrorMessage?: string;\n  withCredentials?: boolean;\n  adapter?: AxiosAdapter;\n  auth?: AxiosBasicCredentials;\n  responseType?: ResponseType;\n  responseEncoding?: responseEncoding | string;\n  xsrfCookieName?: string;\n  xsrfHeaderName?: string;\n  onUploadProgress?: (progressEvent: any) => void;\n  onDownloadProgress?: (progressEvent: any) => void;\n  maxContentLength?: number;\n  validateStatus?: ((status: number) => boolean) | null;\n  maxBodyLength?: number;\n  maxRedirects?: number;\n  socketPath?: string | null;\n  httpAgent?: any;\n  httpsAgent?: any;\n  proxy?: AxiosProxyConfig | false;\n  cancelToken?: CancelToken;\n  decompress?: boolean;\n  transitional?: TransitionalOptions;\n  signal?: AbortSignal;\n  insecureHTTPParser?: boolean;\n}\n\nexport interface HeadersDefaults {\n  common: AxiosRequestHeaders;\n  delete: AxiosRequestHeaders;\n  get: AxiosRequestHeaders;\n  head: AxiosRequestHeaders;\n  post: AxiosRequestHeaders;\n  put: AxiosRequestHeaders;\n  patch: AxiosRequestHeaders;\n  options?: AxiosRequestHeaders;\n  purge?: AxiosRequestHeaders;\n  link?: AxiosRequestHeaders;\n  unlink?: AxiosRequestHeaders;\n}\n\nexport interface AxiosDefaults<D = any> extends Omit<AxiosRequestConfig<D>, 'headers'> {\n  headers: HeadersDefaults;\n}\n\nexport interface AxiosResponse<T = any, D = any>  {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: AxiosResponseHeaders;\n  config: AxiosRequestConfig<D>;\n  request?: any;\n}\n\nexport interface AxiosError<T = any, D = any> extends Error {\n  config: AxiosRequestConfig<D>;\n  code?: string;\n  request?: any;\n  response?: AxiosResponse<T, D>;\n  isAxiosError: boolean;\n  toJSON: () => object;\n}\n\nexport interface AxiosPromise<T = any> extends Promise<AxiosResponse<T>> {\n}\n\nexport interface CancelStatic {\n  new (message?: string): Cancel;\n}\n\nexport interface Cancel {\n  message: string | undefined;\n}\n\nexport interface Canceler {\n  (message?: string): void;\n}\n\nexport interface CancelTokenStatic {\n  new (executor: (cancel: Canceler) => void): CancelToken;\n  source(): CancelTokenSource;\n}\n\nexport interface CancelToken {\n  promise: Promise<Cancel>;\n  reason?: Cancel;\n  throwIfRequested(): void;\n}\n\nexport interface CancelTokenSource {\n  token: CancelToken;\n  cancel: Canceler;\n}\n\nexport interface AxiosInterceptorManager<V> {\n  use<T = V>(onFulfilled?: (value: V) => T | Promise<T>, onRejected?: (error: any) => any): number;\n  eject(id: number): void;\n}\n\nexport class Axios {\n  constructor(config?: AxiosRequestConfig);\n  defaults: AxiosDefaults;\n  interceptors: {\n    request: AxiosInterceptorManager<AxiosRequestConfig>;\n    response: AxiosInterceptorManager<AxiosResponse>;\n  };\n  getUri(config?: AxiosRequestConfig): string;\n  request<T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R>;\n  get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  delete<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  head<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  options<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  post<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  put<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  patch<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n}\n\nexport interface AxiosInstance extends Axios {\n  (config: AxiosRequestConfig): AxiosPromise;\n  (url: string, config?: AxiosRequestConfig): AxiosPromise;\n}\n\nexport interface AxiosStatic extends AxiosInstance {\n  create(config?: AxiosRequestConfig): AxiosInstance;\n  Cancel: CancelStatic;\n  CancelToken: CancelTokenStatic;\n  Axios: typeof Axios;\n  readonly VERSION: string;\n  isCancel(value: any): boolean;\n  all<T>(values: Array<T | Promise<T>>): Promise<T[]>;\n  spread<T, R>(callback: (...args: T[]) => R): (array: T[]) => R;\n  isAxiosError(payload: any): payload is AxiosError;\n}\n\ndeclare const axios: AxiosStatic;\n\nexport default axios;\n"],"names":["Axios","axios"],"mappings":";;AAuLO,GAAK,CAACA,KAAK,SAALA,KAAK;;QAALA,KAAK,GAALA,KAAK;eAqCHC,KAAK"}